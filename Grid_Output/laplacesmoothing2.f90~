program laplacesmoothing2
   implicit none
   integer, parameter :: imax=100,jmax=20
   integer, parameter :: dimi=imax+1, dimj=jmax+1
   real               :: de, dn  !delta used in gauss sidel
   integer            :: i,j,itr,xint2,xint3
  
   real, dimension(dimi,dimj)     :: x,y
   real                           :: x_prev,y_prev,err_sum1,err_sum2,err_tot
   real, dimension(dimi-2,dimj-2) :: a,b,g,c,a1,a2,a3,a4,a5,a6,a7,a8
   real, dimension(dimi)          :: slope 
   de=1.0/(dimj-1)
   dn=1.0/(dimi-1)

   !store variables in xfinal matrix
   open(UNIT=1,FILE="XFINAL.dat",FORM="UNFORMATTED",STATUS="OLD",ACTION="READ")
   do i=1,dimi*dimj
      !READ(1) x((i-1)/dimj+1, MOD((i-1),dimj)+1)
      read(1) x( MOD((i-1),dimi)+1 , (i-1)/dimi+1 )
   end do
   close(1)
  
   !store variables in yfinal matrix
   open(UNIT=2,FILE="YFINAL.dat",FORM="UNFORMATTED",STATUS="OLD",ACTION="READ")
   do i=1,dimi*dimj
      !READ(1) y((i-1)/dimj+1, MOD((i-1),dimj)+1)
      read(2) y( MOD((i-1),dimi)+1 , (i-1)/dimi+1 )
   end do
   close(2)

   print *, "Initial X"
   print "(26F7.3)", x
   print *, "Initial Y"
   print "(26F7.3)", y

   !print *, "bottom line slope"
   !creating vector to hold bottom line slope values (from slope at i is (Y(1,i+1)-Y(1,i-1))/(X(1,i+1)-X(1,i-1)))
   !do i=2,dimi-1 
   !   slope(i) = (y(i+1,1)-y(i-1,1))/(x(i+1,1)-x(i-1,1))
   !   print *, slope(i)
      !alternative slope calculation   
      !if (i <= dimi/2) then
      !   slope(i) = (y(i,1)-y(i-2,1))/(x(i,1)-x(i-2,1))
      !else if (i > dimi/2) then
      !   slope(i) = (y(i,1)-y(i+2,1))/(x(i,1)-x(i+2,1))
      !end if
      !print *,  slope(i)  
   !end do
   !slope(1) = 0.0
   !slope(dimi) = 0.0

  
   !code to adjust (x,y)[l] by laplace smoothing
      
      do itr=1,5000
         err_sum1 = 0
         err_sum2 = 0
         err_tot  = 0


         !WHILE LOOP for every iteration here
         !constants are only calculated for the interior nodes (range from 2->dimi-1, 2->dimj-1)
         do i=2,dimi-1
            do j=2,dimj-1
               a(i-1,j-1)=1/(4*dn**2)*((x(i,j+1)-x(i,j-1))**2+(y(i,j+1)-y(i,j-1))**2)&
                    +10.0**(-9.0)
               b(i-1,j-1)=1/(4*de*dn)*((x(i+1,j)-x(i-1,j))*(x(i,j+1)-x(i,j-1))+(y(i+1,j)-y(i-1,j))*(y(i,j+1)-y(i,j-1)))&
                    +10.0**(-9.0)
               g(i-1,j-1)=1/(4*de**2)*((x(i+1,j)-x(i-1,j))**2+(y(i+1,j)-y(i-1,j))**2)&
                    +10.0**(-9.0)
               c(i-1,j-1)=2*a(i-1,j-1)/de**2+2*g(i-1,j-1)/dn**2


               a1(i-1,j-1)= a(i-1,j-1)  / (de**2*c(i-1,j-1))
               a2(i-1,j-1)= a(i-1,j-1)  / (de**2*c(i-1,j-1))
               a3(i-1,j-1)= -b(i-1,j-1) / (2*de*dn*c(i-1,j-1))
               a4(i-1,j-1)= b(i-1,j-1)  / (2*de*dn*c(i-1,j-1))
               a5(i-1,j-1)= b(i-1,j-1)  / (2*de*dn*c(i-1,j-1))
               a6(i-1,j-1)= -b(i-1,j-1) / (2*de*dn*c(i-1,j-1))
               a7(i-1,j-1)= g(i-1,j-1)  / (dn**2*c(i-1,j-1))
               a8(i-1,j-1)= g(i-1,j-1)  / (dn**2*c(i-1,j-1))
            end do
         end do

         !now that all the constants for this iteration have been calculated... commence with gauss sidel
         !iterate over all interior points (exterior are the BC and will not be changed)
         do i=2,dimi-1
            do j=2,dimj-1
               x_prev = x(i,j)
               x(i,j) = a1(i-1,j-1)*x(i+1,j) &
                    +a2(i-1,j-1)*x(i-1,j)    &
                    +a3(i-1,j-1)*x(i+1,j+1)  &
                    +a4(i-1,j-1)*x(i-1,j+1)  &
                    +a5(i-1,j-1)*x(i+1,j-1)  &
                    +a6(i-1,j-1)*x(i-1,j-1)  &
                    +a7(i-1,j-1)*x(i,j+1)    &
                    +a8(i-1,j-1)*x(i,j-1)
               err_sum1 = err_sum1 + x(i,j)-x_prev
            end do
         end do

         do i=2,dimi-1
            do j=2,dimj-1
               y_prev = y(i,j) 
               y(i,j) = a1(i-1,j-1)*y(i+1,j) &
                    +a2(i-1,j-1)*y(i-1,j)    &
                    +a3(i-1,j-1)*y(i+1,j+1)  &
                    +a4(i-1,j-1)*y(i-1,j+1)  &
                    +a5(i-1,j-1)*y(i+1,j-1)  &
                    +a6(i-1,j-1)*y(i-1,j-1)  &
                    +a7(i-1,j-1)*y(i,j+1)    &
                    +a8(i-1,j-1)*y(i,j-1)
               err_sum2 = err_sum2 + y(i,j)-y_prev
            end do
         end do

         !impose bc neumann on top (perpindicular) this will allow for adjustable spacing in x on top
         !do i=1,dimi
         !   x(i,dimj) = x(i,dimj-1)
         !end do

         !impose neumann bc... only really need along bottom (perpindicular to the slope of bottom line)
         !adjust internal x and y so that [y(2,i)-y(1,i)]/[x(2,i)-x(1,i)] = slope
         if (itr >= 500) then
            xint2 = 1
            xint3 = 1
            do i=1,dimi

               !slope fisrt interior line
               slope(i) = (y(i+1,2)-y(i-1,2))/(x(i+1,2)-x(i-1,2))

               !enforcing neumann perpindilularity
               if (slope(i) /= 0) then
                  x(i,1) = (x(i,1)*slope(i)+x(i,2)*(1/slope(i))+y(i,2)-y(i,1)) / (slope(i)+(1/slope(i)))       
                  y(i,1) = y(i,1) + (x(i,2)-x(i,1))*slope(i)
                  !else if (slope(i)==0) then
                  !x(i,2) =  x(i,1)
               end if

               !enforcing direchlet boundaries
               if (x(i,1) <= 2.0 .or. x(i,1) >= 3.0) then
                  y(i,1) = 0.0
               else if (x(i,1) > 2.0 .and. x(i,1) < 3.0) then
                  y(i,1) = 0.0*sin(3.14159*(x(i,1)-2.0))
               end if

               !finding points closets to (2.0,0) and (3.0,0)
               if (abs(x(i,1)-2.0) < abs(x(xint2,1)-2.0)) then
                  xint2 = i
               end if

               if (abs(x(i,1)-3.0) < abs(x(xint3,1)-3.0)) then
                  xint3 = i
               end if
            end do
         end if

         !setting edge points for clean piecewise function
         x(xint2,1) = 2.0
         y(xint2,1) = 0.0
         x(xint3,1) = 3.0
         y(xint3,1) = 0.0
         x(1,1)     = 0.0

         !create mesure for error (avg change for all points)
         err_tot = err_sum1 + err_sum2
         !print "(16F7.3)", x
         !print "(16F7.3)", y
         !print *, err_tot
      end do



   open(UNIT=3,FILE="smoothgrid.txt",FORM="FORMATTED",STATUS="REPLACE",ACTION="WRITE")
   do i = 1, dimi-1
      do j = 1, dimj-1 !each i,j combo will produce the line path of a cell
         write(3,*) x(i,j), y(i,j)
         write(3,*) x(i+1,j), y(i+1,j)
         write(3,*) x(i+1,j+1), y(i+1,j+1)
         write(3,*) x(i,j+1), y(i,j+1)
         write(3,*) x(i,j), y(i,j)
         write(3,*)
      end do
   end do
   close(3)

  open(unit=4,file="Xsmooth.dat",form="unformatted",status="replace",action="write")
  open(unit=5,file="Ysmooth.dat",form="unformatted",status="replace",action="write")
  write(4) dimi, dimj
  write(5) dimi, dimj
  do i=1,dimi
     do j=1,dimj
        write(4) x(i,j)
        write(5) y(i,j)
        print *, x(i,j), y(i,j)
     end do
  end do

  print *, "X matrix"
  print "(21F7.3)", x
  print *, "Y matrix"
  print "(21F7.3)", y
  
  close(4)
  close(5)
   
   

   call execute_command_line('gnuplot -p plotsmooth.plt')



end program laplacesmoothing2
